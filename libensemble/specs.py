import ipaddress
import os
import random
from typing import Any, Callable, Dict, List, Optional, Tuple, Union

import numpy as np
from pydantic import BaseConfig, BaseModel, Field, root_validator, validator

from libensemble.utils.specs_checkers import (
    _check_any_workers_and_disable_rm_if_tcp,
    _check_exit_criteria,
    _check_H0,
    _check_output_fields,
    _MPICommValidationModel,
)

BaseConfig.arbitrary_types_allowed = True

__all__ = ["SimSpecs", "GenSpecs", "AllocSpecs", "ExitCriteria", "LibeSpecs", "EnsembleSpecs"]


class SimSpecs(BaseModel):
    """
    Specifications for configuring a Simulation Function. Equivalent to
    the sim_specs dictionary with automatic validation of inputs
    """

    sim_f: Callable
    """
    Python function that matches the sim_f api. e.g. `libensemble.sim_funcs.borehole`. Evaluates parameters
    produced by a generator function
    """

    inputs: List[str] = Field([], alias="in")
    """
    List of field names out of the complete history to pass
    into the simulation function on initialization
    """

    persis_in: Optional[List[str]] = []
    """
    List of field names that will be passed to a persistent simulation function
    throughout runtime, following initialization
    """

    # list of tuples for dtype construction
    out: List[Union[Tuple[str, Any], Tuple[str, Any, Union[int, Tuple]]]] = []
    """
    List of tuples corresponding to NumPy dtypes. e.g. ("dim", int, (3,)), or ("path", str).
    Typically used to initialize an output array within the simulation function:
    `out = np.zeros(100, dtype=sim_specs["out"])`.
    Also used to construct the complete dtype for libEnsemble's history array
    """

    funcx_endpoint: Optional[str] = ""
    """
    A funcX (https://funcx.org/) ID corresponding to an active endpoint on a remote system. libEnsemble's workers
    will submit simulator function instances to this endpoint to be executed, instead of being called in-place
    """

    user: Optional[Dict]
    """
    A user-data dictionary to place bounds, constants, settings, or other parameters for customizing
    the simulator function
    """


class GenSpecs(BaseModel):
    """
    Specifications for configuring a Generator Function. Equivalent to
    the gen_specs dictionary with automatic validation of inputs
    """

    gen_f: Optional[Callable]
    """
    Python function that matches the gen_f api. e.g. `libensemble.gen_funcs.sampling`. Produces parameters for
    evaluation by a simulator function, and makes decisions based on simulation function output.
    """

    inputs: Optional[List[str]] = Field([], alias="in")
    """
    List of field names out of the complete history to pass
    into the simulation function on initialization
    """

    persis_in: Optional[List[str]] = []
    """
    List of field names that will be passed to a persistent generator function
    throughout runtime, following initialization
    """

    out: List[Union[Tuple[str, Any], Tuple[str, Any, Union[int, Tuple]]]] = []
    """
    List of tuples corresponding to NumPy dtypes. e.g. ("dim", int, (3,)), or ("path", str).
    Typically used to initialize an output array within the generator function:
    `out = np.zeros(100, dtype=gen_specs["out"])`. Also used to construct the complete dtype for libEnsemble's
    history array
    """

    funcx_endpoint: Optional[str] = ""
    """
    A funcX (https://funcx.org/) ID corresponding to an active endpoint on a remote system. libEnsemble's workers
    will submit generator function instances to this endpoint to be executed, instead of being called in-place
    """

    user: Optional[Dict]
    """
    A user-data dictionary to place bounds, constants, settings, or other parameters for customizing the generator
    function
    """


class AllocSpecs(BaseModel):
    """
    Specifications for configuring an Allocation Function. Equivalent to
    the alloc_specs dictionary with automatic validation of inputs
    """

    alloc_f: Callable
    """
    Python function that matches the alloc_f api. e.g. `libensemble.alloc_funcs.give_sim_work_first`. Decides if and
    when simulator and generator functions should be called, and with what resources and parameters
    """

    user: Optional[Dict]
    """
    A user-data dictionary to place bounds, constants, settings, or other parameters for customizing the allocation
    function
    """


class ExitCriteria(BaseModel):
    """
    Specifications for configuring when libEnsemble should stop a given run. Equivalent to the
    exit_criteria dictionary with automatic validation of inputs
    """

    sim_max: Optional[int] = 100
    """
    Stop when this many new points have been evaluated by simulation functions
    """

    gen_max: Optional[int]
    """
    Stop when this many new points have been generated by generator functions
    """

    wallclock_max: Optional[float]
    """
    Stop when this much time has elapsed since the manager initialized
    """

    stop_val: Optional[Tuple[str, float]]
    """
    Stop when `H[str] < float` for the given (str, float) pair
    """


class LibeSpecs(BaseModel):
    abort_on_exception: Optional[bool] = True
    enforce_worker_core_bounds: Optional[bool] = False
    authkey: Optional[str] = f"libE_auth_{random.randrange(99999)}"
    disable_resource_manager: Optional[bool] = False
    dedicated_mode: Optional[bool] = False
    comms: str = "mpi"
    resource_info: Optional[Dict] = {}
    disable_log_files: Optional[bool] = False
    final_fields: Optional[List[str]] = []
    ip: Optional[ipaddress.IPv4Address] = None
    kill_canceled_sims: Optional[bool] = True
    mpi_comm: Optional[_MPICommValidationModel] = None  # see utils/specs_checkers.py
    num_resource_sets: Optional[int]
    nworkers: Optional[int]
    port: Optional[int] = 0
    profile: Optional[bool] = False
    safe_mode: Optional[bool] = True
    save_every_k_gens: Optional[int] = 0
    save_every_k_sims: Optional[int] = 0
    save_H_and_persis_on_abort: Optional[bool] = True
    scheduler_opts: Optional[Dict] = {}
    stats_fmt: Optional[Dict] = {}
    use_persis_return_gen: Optional[bool] = False
    use_persis_return_sim: Optional[bool] = False
    workerID: Optional[int]
    worker_timeout: Optional[int] = 1
    zero_resource_workers: Optional[List[int]] = []
    worker_cmd: Optional[List[str]]
    workers: Optional[List[str]]
    ensemble_copy_back: Optional[bool] = False
    ensemble_dir_path: Optional[str] = "./ensemble"
    use_worker_dirs: Optional[bool] = False
    sim_dirs_make: Optional[bool] = False
    sim_dir_copy_files: Optional[List[str]] = []
    sim_dir_symlink_files: Optional[List[str]] = []
    sim_input_dir: Optional[str] = ""
    gen_dirs_make: Optional[bool] = False
    gen_dir_copy_files: Optional[List[str]] = []
    gen_dir_symlink_files: Optional[List[str]] = []
    gen_input_dir: Optional[str] = ""

    class Config:
        arbitrary_types_allowed = True

    @validator("comms")
    def check_valid_comms_type(cls, value):
        assert value in ["mpi", "local", "tcp"], "Invalid comms type"
        return value

    @validator("sim_input_dir", "gen_input_dir")
    def check_input_dir_exists(cls, value):
        assert os.path.exists(value), "libE_specs['{}'] does not refer to an existing path.".format(value)
        return value

    @validator("sim_dir_copy_files", "sim_dir_symlink_files", "gen_dir_copy_files", "gen_dir_symlink_files")
    def check_inputs_exist(cls, value):
        for f in value:
            assert os.path.exists(f), "'{}' in libE_specs['{}'] does not refer to an existing path.".format(f, value)
        return value

    @root_validator
    def check_any_workers_and_disable_rm_if_tcp(cls, values):
        return _check_any_workers_and_disable_rm_if_tcp(cls, values)

    @root_validator
    def set_defaults_on_mpi(cls, values):
        if values.get("comms") == "mpi":
            if not values.get("mpi_comm"):
                from mpi4py import MPI

                values["mpi_comm"] = MPI.COMM_WORLD
        return values


class EnsembleSpecs(BaseModel):
    H0: Optional[np.ndarray] = None
    libE_specs: LibeSpecs
    sim_specs: SimSpecs
    gen_specs: Optional[GenSpecs]
    exit_criteria: ExitCriteria
    persis_info: Optional[Dict]
    alloc_specs: Optional[AllocSpecs]
    nworkers: Optional[int]

    class Config:
        arbitrary_types_allowed = True

    @root_validator
    def check_exit_criteria(cls, values):
        return _check_exit_criteria(cls, values)

    @root_validator
    def check_output_fields(cls, values):
        return _check_output_fields(cls, values)

    @root_validator
    def set_ensemble_nworkers(cls, values):
        if values.get("libE_specs"):
            values["nworkers"] = values["libE_specs"].nworkers
        return values

    @root_validator
    def check_H0(cls, values):
        if values.get("H0") is not None:
            return _check_H0(cls, values)
        return values
